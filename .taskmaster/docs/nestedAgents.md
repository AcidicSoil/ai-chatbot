Detected stack and scope

* Framework: Next.js App Router (app directory with segment-based routing and route handlers).
* Data layer: Drizzle ORM with Postgres (schema.ts, queries.ts, migrations under lib/db).
* Auth: NextAuth (Auth.js) credentials + guest providers under app/(auth).
* AI: Vercel AI SDK (`ai`), custom provider wiring X.ai, LM Studio, Gemini.
* UI shell: React Server Components + client components in app, artifacts, components, hooks.

AGENTS.md will be generated for these architecturally key directories:

1. `app/(chat)` – chat UI + HTTP boundary for chat-related APIs.
2. `app/(auth)` – identity/session boundary and auth UI.
3. `lib/db` – Drizzle schema, migrations, and query layer.
4. `lib/ai` – AI models, prompts, tools, and providers.
5. `artifacts` – artifact-oriented UI + server orchestration for text/code/sheet artifacts.

---

# AGENTS.md for `app/(chat)`

```md
<!-- Generated by Ruler -->

<!-- Inherits from: .ruler/AGENTS.md -->

# Directory: app/(chat)

## Hierarchical Policy

- This directory inherits all global rules from `.ruler/AGENTS.md` and specializes them for the chat surface and chat HTTP endpoints.
- Owns:
  - Chat pages, layouts, and streaming UI for chat sessions.
  - Chat-related server actions in `actions.ts`.
  - Chat-related App Router route handlers under `app/(chat)/api/**`.
- May depend on:
  - `@/app/(auth)/auth` for session access.
  - `@/lib/db/queries` for persistence.
  - `@/lib/ai/**` for model calls and prompts.
  - `@/artifacts/**`, `@/components/**`, `@/hooks/**` for UI/domain helpers.
- Must not depend on:
  - Drizzle directly (`drizzle-orm`, `postgres`) or DB migrations.
  - NextAuth configuration internals other than the exported `auth`, `signIn`, `signOut`.
  - Low-level AI provider wiring (only use `myProvider` and other exported facades from `lib/ai`).

## Domain Vocabulary

- `Chat`: A long-lived conversation record stored via `lib/db/queries` (id, title, visibility, user ownership).
- `Message`: A persisted chat message; UI uses “UIMessage” projections.
- `Stream`: A streaming session of model output associated with a chat.
- `VisibilityType`: Public/private visibility of a chat.
- `DataStreamProvider` / `DataStreamHandler`: Components wiring server-side data streams into the chat UI.
- `artifactKinds`: `"text" | "code" | "sheet"` artifact types associated with a chat.
- `chat-model` / `chat-model-reasoning`: Primary AI models for chat; configured in `lib/ai/providers`.

## Allowed Patterns

### Next.js App Router: pages and layouts

1. Pages and layouts in this segment:
   - Default export a React component; pages may be async server components.
   - For initial data, call `auth()` and `lib/db/queries` functions directly from server components.
   - Use Suspense boundaries for loading states; keep fallback UIs minimal and layout-safe.
2. URL and params:
   - Route params are accessed via typed `params` where possible; do not parse from `searchParams` if you have path params.
   - Use the `redirect` and `notFound` helpers from `next/navigation` for control-flow, not manual `NextResponse` in pages.

### Route handlers under `app/(chat)/api/**`

1. Shape:
   - Export `GET`, `POST`, `PATCH`, `DELETE`, etc. as `export async function` for each HTTP verb.
   - Accept `Request` or Next’s `NextRequest` as the first argument.
2. Authentication:
   - Always call `auth()` for endpoints that operate on user-owned chats or messages.
   - Treat unauthenticated requests as errors using `ChatSDKError` where appropriate.
3. Validation:
   - Parse query params via `new URL(request.url).searchParams`.
   - For JSON bodies, use `await request.json()` and validate via Zod schemas when the data is non-trivial.
   - Return typed error responses via `ChatSDKError` for missing/invalid params.
4. Data access:
   - Only call persistence through `@/lib/db/queries` functions.
   - Obtain any DB types via `@/lib/db/schema` types, not direct `drizzle` queries.
5. Responses:
   - Use `Response.json(...)` or `NextResponse.json(...)` for successful responses.
   - For domain errors, return `.toResponse()` from `ChatSDKError` instead of throwing raw errors.

### Server actions in `app/(chat)/actions.ts`

1. Mark file-level `"use server"` and export server actions which:
   - Parse and validate input synchronously.
   - Call `generateText` / AI SDK functions through `myProvider` or higher-level wrappers in `lib/ai`.
   - Call `lib/db/queries` for any persistence updates.
2. Side effects:
   - Use `cookies()` for persisting lightweight per-user flags like preferred chat model.
   - Avoid performing multi-step, cross-entity business flows directly in actions; delegate to dedicated functions in `lib/**` when logic grows.

### Interaction with artifacts

1. For generating or updating artifacts as part of a chat:
   - Delegate to handlers in `artifacts/**` and `lib/artifacts/server`.
   - Treat artifact creation/update as separate domain operations, not inline string manipulations in route handlers.

## Prohibited Patterns

1. No direct DB access:
   - Forbidden to import `drizzle-orm`, `postgres`, or create DB clients in this directory.
   - Forbidden to run raw SQL or touch migrations.
2. No low-level auth configuration:
   - Do not instantiate `NextAuth` here.
   - Do not alter `authConfig`; only call exported `auth`, `signIn`, `signOut`.
3. No business logic in React client components:
   - Client components must not call fetch on internal `/api` routes for operations available as server actions or direct server calls.
   - Client components must not import `@/lib/db/queries` or `@/lib/ai/providers`; those belong in server-only files.
4. No arbitrary access to cookies:
   - Use cookies only for stable, simple preferences (e.g., chat model) and not as an ad-hoc data store.

## Boundaries

- Upstream callers:
  - Entry point for chat UX is via routes under `app/(chat)`; external code must not call lower-level `app/(chat)/api/**` endpoints directly from the server—prefer function calls in `lib/**`.
- Downstream dependencies:
  - Allowed: `@/app/(auth)/auth`, `@/lib/db/**`, `@/lib/ai/**`, `@/lib/artifacts/**`, `@/components/**`, `@/hooks/**`, `@/lib/constants`, `@/lib/errors`, `@/lib/utils`.
  - Forbidden: `lib/db/migrations`, low-level provider setup outside `lib/ai/providers`, any future `scripts/**` or CLI-only utilities.
- Cross-segment isolation:
  - This segment must not import from other app segments (e.g., `app/avatar/**`) except shared UI-only components; cross-feature server logic belongs in `lib/**`.
```

---

# AGENTS.md for `app/(auth)`

```md
<!-- Generated by Ruler -->

<!-- Inherits from: .ruler/AGENTS.md -->

# Directory: app/(auth)

## Hierarchical Policy

- This directory inherits global rules from `.ruler/AGENTS.md` and specializes them for authentication and session management.
- Owns:
  - NextAuth configuration and handler exports (`auth.config.ts`, `auth.ts`).
  - Auth-related pages (`login`, `register`).
  - Auth-related API endpoints under `app/(auth)/api/**`.
- Exposes:
  - `auth`, `signIn`, `signOut`, `handlers.GET`, `handlers.POST` as the only entry-points other segments may use.

## Domain Vocabulary

- `UserType`: `"guest" | "regular"`; persisted via NextAuth JWT and added to `Session`.
- `authConfig`: Shared NextAuth configuration object used by `NextAuth`.
- Credentials provider: Email/password sign-in backed by `lib/db/queries`.
- Guest provider: Ephemeral guest account creation backed by `lib/db/queries`.
- `DUMMY_PASSWORD`: Dummy password used to prevent user enumeration side channels.

## Allowed Patterns

### NextAuth configuration and handlers

1. Configure NextAuth once in `auth.ts`:
   - Spread `authConfig` and extend with providers and callbacks.
   - Use `Credentials` providers for both regular and guest user flows.
2. User resolution:
   - Fetch user(s) via `getUser` from `@/lib/db/queries`.
   - Use `compare` from `bcrypt-ts` to verify passwords when the user exists.
   - For non-existent or invalid users, always perform a dummy `compare` to avoid timing leaks.
3. Session and JWT:
   - Extend `Session` and `JWT` types in-module; ensure `id` and `type` are set consistently.
   - All other code uses `auth()` instead of decoding tokens manually.

### Auth pages (`login`, `register`)

1. Client pages:
   - Use `useSession` only for client-only status checks; do not perform redirects using window APIs.
   - Use `useActionState` or server actions for form submission.
   - Display user feedback via toasts or inline messages; never expose raw error messages from DB or Auth.js.
2. Routing:
   - Redirect authenticated users away from login/register pages using router navigation (e.g., `router.replace("/")`), not manual location changes.
   - Use `authConfig.pages` to drive default sign-in and new-user routes.

### Auth APIs (`app/(auth)/api/**`)

1. Guest auth:
   - For `/api/auth/guest`, use `getToken` from `next-auth/jwt` to detect signed-in users and redirect them away.
   - Otherwise, call `signIn("guest", ...)` with redirect semantics only—no manual cookie writes.
2. NextAuth handler re-export:
   - Re-export `{ GET, POST }` for `[...nextauth]/route.ts` from `auth.ts` without wrapping.

## Prohibited Patterns

1. No duplicate NextAuth instances:
   - `NextAuth` must only be called once in this directory.
   - Other files must not call `NextAuth` directly.
2. No direct password hashing outside `lib/db/utils`:
   - Hashing and salting logic must live under `lib/db/utils`; this directory may only compare passwords.
3. No DB queries in client components:
   - Client auth pages must not import `@/lib/db/queries`.
   - All persistence goes via server functions (server actions) or NextAuth flows.
4. No cross-feature coupling:
   - This directory must not import chat-specific code (`@/app/(chat)/**`) or artifact-specific logic.

## Boundaries

- Allowed dependencies:
  - `@/lib/db/queries`, `@/lib/db/utils` (for password ops), `@/lib/constants`.
  - `next-auth`, `next-auth/jwt`, `bcrypt-ts`, Zod for form validation.
- Outgoing dependencies:
  - Other segments (e.g., `app/(chat)`) may import `auth`, `signIn`, `signOut` from this directory.
  - No other exports from this segment should be used as a general-purpose utility layer.
- Layering:
  - `lib/db` must not import from `app/(auth)`; all dependencies are top-down: `app/(auth)` → `lib/db`.
```

---

# AGENTS.md for `lib/db`

```md
<!-- Generated by Ruler -->

<!-- Inherits from: .ruler/AGENTS.md -->

# Directory: lib/db

## Hierarchical Policy

- This directory inherits global rules from `.ruler/AGENTS.md` and specializes them for the data/ORM layer.
- Owns:
  - Drizzle schema definition (`schema.ts`).
  - Database access functions (`queries.ts`).
  - Migrations (`migrations/**`) and migration runner (`migrate.ts`).
  - DB helpers under `helpers/**`.
- Acts as the single source of truth for database structure and access; all app segments must use functions/types from here rather than talking to the DB directly.

## Domain Vocabulary

- Entities:
  - `User`, `Chat`, `Message`, `Suggestion`, `Stream`, `Vote`, `Document`.
- Types:
  - Drizzle table helpers (`pgTable`, `uuid`, `timestamp`, `text`, `boolean`, etc.).
  - `InferSelectModel<typeof table>` for row types.
- Operations:
  - Query helpers: `asc`, `desc`, `eq`, `gt`, `lt`, `and`, `or`, `inArray`, `count`.
  - Error wrapper: `ChatSDKError` for DB-related failures.
- Infrastructure:
  - `migrate.ts`: CLI entry to run Drizzle migrations against `POSTGRES_URL`.

## Allowed Patterns

### Schema and migrations

1. Schema:
   - All tables are defined in `schema.ts` using Drizzle’s `pgTable` APIs.
   - Composite primary keys are expressed via `primaryKey({ columns: [...] })`.
   - Foreign keys are consistently declared using `foreignKey` helpers where needed.
2. Migrations:
   - SQL migrations live under `migrations/**` and must reflect the schema in `schema.ts`.
   - The `migrate.ts` runner:
     - Loads `.env.local` for `POSTGRES_URL`.
     - Creates a single-connection client for running migrations.
     - Exits with non-zero status on error.

### Query functions (`queries.ts`)

1. DB client:
   - Instantiate `postgres` and `drizzle` once at module top-level.
   - Use a single client per process; do not re-create per function call.
2. Query design:
   - Each exported function should perform a single logical DB operation:
     - `getUser`, `createUser`, `createGuestUser`.
     - Chat CRUD and history functions.
     - Message and stream queries.
   - On failure, throw a `ChatSDKError` with a stable error code string (`"bad_request:database"`, `"not_found:chat"`, etc.).
3. Composition:
   - Multi-step operations (e.g., delete a chat + related messages and votes) are implemented as a single function within this layer.
   - Callers in `app/**` or `lib/**` must not orchestrate multiple low-level DB calls themselves.

### Server-only enforcement

1. Use `"server-only"` import guard at the top of DB modules that must not run on the client.
2. Any consumer that imports from `lib/db/queries` must be a server-only file (route handler, server component, server action, or lib server module).

## Prohibited Patterns

1. No React or Next-specific imports:
   - Do not import `NextResponse`, `Request`, `cookies`, or any React/Next modules into `lib/db`.
2. No client-side usage:
   - Never import `lib/db/queries` into `"use client"` components or browser-only code.
3. No environment access outside configuration:
   - Only `migrate.ts` and the DB client initialization may read `process.env.POSTGRES_URL`.
   - Other modules must not read arbitrary env variables.
4. No side effects beyond DB:
   - Do not send emails, call external HTTP APIs, or log analytics from this layer; those belong in higher-level services.

## Boundaries

- Incoming dependencies:
  - `app/**` and `lib/**` may import from `lib/db/schema` for types and constants.
  - All database reads/writes from outside must go through `lib/db/queries` or dedicated helper functions here.
- Outgoing dependencies:
  - Allowed: `drizzle-orm`, `postgres`, `dotenv` (for `migrate.ts`), `@/lib/errors`, `@/lib/utils`, `@/lib/usage`.
  - Forbidden: imports from `app/**`, `components/**`, `artifacts/**`, `hooks/**`, or any UI modules.
- Migration boundary:
  - `migrations/**` files are not imported anywhere; they are read by the Drizzle migrator only.
```

---

# AGENTS.md for `lib/ai`

```md
<!-- Generated by Ruler -->

<!-- Inherits from: .ruler/AGENTS.md -->

# Directory: lib/ai

## Hierarchical Policy

- This directory inherits global rules from `.ruler/AGENTS.md` and specializes them for AI model orchestration and tools.
- Owns:
  - Model registry and provider wiring (`providers.ts`).
  - Prompt definitions (`prompts.ts`).
  - AI tools under `tools/**` (e.g., document operations, weather, suggestions).
  - Model metadata and tests (`models.ts`, `models.test.ts`, `models.mock.ts`).
- Provides:
  - A small, stable API (`myProvider`, model IDs, tools) consumed by `app/**` and `artifacts/**`.

## Domain Vocabulary

- `myProvider`: The primary AI provider instance connecting to:
  - X.ai models (e.g., `"xai/grok-2-vision-1212"`, `"xai/grok-3-mini"`).
  - LM Studio models (e.g., `"llama-3.2-1b"`) via local server.
  - Gemini via CLI provider.
- Model IDs:
  - `"chat-model"`, `"chat-model-reasoning"`, `"title-model"`, `"artifact-model"`, `"lmstudio-chat"`, `"gemini-2.5-pro"`.
- Prompts:
  - `codePrompt`, `updateDocumentPrompt`, `titlePrompt`, and any chat/artifact prompts.
- Tools:
  - `create-document`, `update-document`, `request-suggestions`, `get-weather`, etc. as AI “tools” invoked by the models.

## Allowed Patterns

### Provider setup (`providers.ts`)

1. Provider wiring:
   - Define all language models on `myProvider` with stable string IDs.
   - Use wrappers (e.g., `wrapLanguageModel` + `extractReasoningMiddleware`) for reasoning models.
   - Configure environment-sensitive behavior (e.g., `isTestEnvironment` → mock models) inside this file only.
2. Exposure:
   - Export `myProvider` and any structured `models` map.
   - Other modules must not import underlying gateway clients directly.

### Prompt and tool design

1. Prompts:
   - Keep prompts in `prompts.ts` as constants; do not embed long prompt strings in route handlers.
   - Version prompts via explicit constant names (e.g., `*_V2`) when making breaking changes.
2. Tools:
   - Implement tool functions as pure async functions with clearly typed parameters and return values.
   - Validate inputs with Zod where appropriate before calling external APIs.
   - Use these tools from route handlers, server actions, or artifact handlers — not from client components.

### AI usage patterns

1. Streaming:
   - For long-running generations (e.g., artifacts), use streaming APIs (`streamObject` / `streamText`) and forward partial results via data streams.
2. Separation of concerns:
   - Do not mix HTTP concerns (headers, cookies, NextResponse) into AI modules.
   - Do not perform DB writes here; accept already-fetched data or return data for callers to persist via `lib/db/queries`.

## Prohibited Patterns

1. No direct use of provider gateway outside `providers.ts`:
   - All model definitions and provider wiring must remain in `providers.ts`.
2. No UI:
   - Do not import `components`, `hooks`, or any React UI code.
3. No cross-layer coupling:
   - `lib/ai` must not import from `app/**` or `artifacts/**`.
   - Use domain-level data types from `lib/types` or `lib/db/schema` instead.

## Boundaries

- Incoming dependencies:
  - `app/(chat)/actions.ts`, route handlers, and `artifacts/**` are allowed to call into this directory.
- Outgoing dependencies:
  - Allowed: `ai` SDK, provider-specific clients, `zod`, `@/lib/types`, `@/lib/db/schema` (for type references only).
  - Forbidden: `@/lib/db/queries` for writes (keep AI layer free of persistence), `next/*`, `react`, `next-auth`.
- Extension:
  - New models or tools must be registered here and exposed through stable exports, rather than ad-hoc provider calls elsewhere.
```

---

# AGENTS.md for `artifacts`

```md
<!-- Generated by Ruler -->

<!-- Inherits from: .ruler/AGENTS.md -->

# Directory: artifacts

## Hierarchical Policy

- This directory inherits global rules from `.ruler/AGENTS.md` and specializes them for artifact-centric UX (text, code, sheet).
- Owns:
  - Client components for artifact editing and display (`artifacts/**/client.tsx`).
  - Server modules for generating and updating artifacts (`artifacts/**/server.ts`).
  - Integration with the document persistence layer via `lib/artifacts/server` and `lib/db/queries`.
- Coordinates:
  - Streaming generation and update flows powered by AI models configured under `lib/ai`.

## Domain Vocabulary

- `ArtifactKind`: `"text" | "code" | "sheet"`.
- `DocumentHandler<T>`: Interface describing how to create and update artifacts of a specific kind.
- `createDocumentHandler`: Factory in `lib/artifacts/server` to assemble typed handlers.
- `UIMessageStreamWriter<ChatMessage>`: Stream channel for sending incremental artifact updates to the client.
- `draftContent`: The generated or updated artifact body before persistence.

## Allowed Patterns

### Artifact server modules (`artifacts/**/server.ts`)

1. Handler structure:
   - Each artifact kind defines a server module that:
     - Calls `createDocumentHandler` with `{ kind, onCreateDocument, onUpdateDocument }`.
     - Uses AI streaming APIs (`streamObject` / `generateText`, etc.) to produce content.
     - Writes interim deltas to `dataStream` for immediate UI feedback.
   - `onCreateDocument` and `onUpdateDocument` must:
     - Accept typed arguments (ids, titles, descriptions, session).
     - Return the final artifact content (string) to be persisted by `lib/artifacts/server`.
2. Persistence:
   - Defer persistence to the `createDocumentHandler` wrapper in `lib/artifacts/server`, which calls `saveDocument` from `lib/db/queries`.
   - Do not call `saveDocument` directly from artifact-specific modules.

### Artifact client modules (`artifacts/**/client.tsx`)

1. Client-only:
   - Mark client components with `"use client"` where they use hooks.
   - Display streamed deltas and final content via props and context from the server side.
2. Behavior:
   - Keep client components focused on presentation, editing controls, and event wiring.
   - All heavy business logic and AI calls stay in server modules or `lib/**`.

### Integration with chat and documents

1. When invoked from chat flows:
   - Treat artifact generation as side-effect of chat interaction.
   - Provide chat context (messages, user/session) as inputs to handlers; avoid having handlers fetch chat data themselves.
2. Document identity:
   - Artifact handlers operate on `Document` entities defined in `lib/db/schema`.
   - Use document ids and metadata passed in from callers; no direct DB queries from this directory.

## Prohibited Patterns

1. No direct DB writes:
   - Do not import `drizzle-orm`, `postgres`, or `lib/db/queries` into top-level artifact modules (except `lib/artifacts/server`, which is already part of lib).
2. No auth or session configuration:
   - Do not import or call `NextAuth` configuration; rely on `Session` passed into server handlers.
3. No AI provider wiring:
   - Do not configure models or providers here; use `myProvider` and factory functions from `lib/ai`.

## Boundaries

- Allowed dependencies:
  - From `artifacts/**` into:
    - `@/lib/ai/prompts`, `@/lib/ai/providers`.
    - `@/lib/artifacts/server` for handler composition.
    - `@/lib/db/schema` and `@/lib/db/queries` only via `lib/artifacts/server`.
    - `@/components/**` for shared UI, `@/lib/types` for shared domain types.
- Forbidden dependencies:
  - Direct imports from `app/(chat)` or `app/(auth)`; communication must flow via function calls and props from callers.
  - Imports from `lib/db/migrations` or CLI helper scripts.
- Ownership:
  - Artifact UX and streaming behavior are owned here; chat pages must not reimplement artifact generation logic inline.
```
